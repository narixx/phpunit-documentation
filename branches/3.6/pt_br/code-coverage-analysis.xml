<?xml version="1.0" encoding="utf-8" ?>

<chapter id="code-coverage-analysis">
  <title>Code Coverage Analysis</title>

  <blockquote>
    <attribution>Murali Nandigama</attribution>
    <para>
      The beauty of testing is found not in the effort but in the effiency.
    </para>
    <para>
      - A beleza do teste não é encontrado no esforço, mas na eficiência.
    </para>
    <para>
      Knowing what should be tested is beautiful, and knowing what is being
      tested is beautiful.
    </para>
    <para>
      - Saber o que deve ser testado é lindo, e saber o que está sendo
      testado é lindo.
    </para>
  </blockquote>

  <para>
    <indexterm><primary>Code Coverage (Cobertura de código)</primary></indexterm>

    Neste capítulo você irá aprender tudo sobre PHPUnit's cobertura de código
    funcionalidade que fornece uma visão de quais partes do código
    produzido são executados quando os testes são executados. Ela ajuda a responder perguntas
    como:
  </para>

  <itemizedlist>
    <listitem>
      <para>
        Como você encontrar código que ainda não é testado -- ou, em outras palavrar, ainda
        não <emphasis>coberto</emphasis> por um teste?
      </para>
    </listitem>
    <listitem>
      <para>Como você mede testes completo?</para>
    </listitem>
  </itemizedlist>

  <para>
    Um exemplo de que estatistícas de cobertura de código pode dizer é que se houver um
    método com 100 linhas de código, e apenas 75 dessas linhas são realmente
    executadas quando testes estão sendo executados, o método é considerado como tendo uma
    cobertura de código de 75 por cento.
  </para>

  <para>
    <indexterm><primary>Xdebug</primary></indexterm>

    PHPUnit's funcionalidade de cobertura de código faz uso do
    <ulink url="http://github.com/sebastianbergmann/php-code-coverage">PHP_CodeCoverage</ulink>
    componente, que por sua vez aproveita a funcionalidade de cobertura
    fornecida pelo <ulink url="http://www.xdebug.org/">Xdebug</ulink>
    extensão para PHP.
  </para>

  <para>
    Let us generate a code coverage report for the <literal>BankAccount</literal>
    class from <xref linkend="test-driven-development.bankaccount-example.examples.BankAccount2.php" />.
  </para>

  <screen><userinput>phpunit --coverage-html ./report BankAccountTest</userinput>
PHPUnit 3.6.0 by Sebastian Bergmann.

...

Time: 0 seconds

OK (3 tests, 3 assertions)

Generating report, this may take a moment.</screen>

  <para>
    <xref linkend="code-coverage-analysis.figures.Code_Coverage.png" /> shows
    an excerpt from a Code Coverage report. Lines of code that were executed
    while running the tests are highlighted green, lines of code that are
    executable but were not executed are highlighted red, and "dead code" is
    highlighted grey. The number left to the actual line of code indicates
    how many tests cover that line.
  </para>

  <figure id="code-coverage-analysis.figures.Code_Coverage.png">
    <title>Code Coverage for <literal>setBalance()</literal></title>

    <graphic fileref="figures/Code_Coverage.png" />
  </figure>

  <para>
    Clicking on the line number of a covered line will open a panel (see
    <xref linkend="code-coverage-analysis.figures.Code_Coverage2.png"/>) that
    shows the test cases that cover this line.
  </para>

  <figure id="code-coverage-analysis.figures.Code_Coverage2.png">
    <title>Panel with information on covering tests</title>

    <graphic fileref="figures/Code_Coverage2.png" />
  </figure>

  <para>
    The code coverage report for our <literal>BankAccount</literal> example
    shows that we do not have any tests yet that call the
    <literal>setBalance()</literal>, <literal>depositMoney()</literal>, and
    <literal>withdrawMoney()</literal> methods with legal values.
    <xref linkend="code-coverage-analysis.examples.BankAccountTest.php" />
    shows a test that can be added to the <literal>BankAccountTest</literal>
    test case class to completely cover the <literal>BankAccount</literal>
    class.
  </para>

  <example id="code-coverage-analysis.examples.BankAccountTest.php">
    <title>Test missing to achieve complete code coverage</title>
    <programlisting><![CDATA[<?php
require_once 'BankAccount.php';

class BankAccountTest extends PHPUnit_Framework_TestCase
{
    // ...

    public function testDepositWithdrawMoney()
    {
        $this->assertEquals(0, $this->ba->getBalance());
        $this->ba->depositMoney(1);
        $this->assertEquals(1, $this->ba->getBalance());
        $this->ba->withdrawMoney(1);
        $this->assertEquals(0, $this->ba->getBalance());
    }
}
?>]]></programlisting>
  </example>

  <para>
    <xref linkend="code-coverage-analysis.figures.Code_Coverage3.png" /> shows
    the code coverage of the <literal>setBalance()</literal> method with the
    additional test.
  </para>

  <figure id="code-coverage-analysis.figures.Code_Coverage3.png">
    <title>Code Coverage for <literal>setBalance()</literal> with additional test</title>

    <graphic fileref="figures/Code_Coverage3.png" />
  </figure>

  <section id="code-coverage-analysis.specifying-covered-methods">
    <title>Specifying Covered Methods</title>

    <para>
      <indexterm><primary>Annotation</primary></indexterm>
      <indexterm><primary>@covers</primary></indexterm>

      The <literal>@covers</literal> annotation (see
      <xref linkend="appendixes.annotations.covers.tables.annotations"/>) can be
      used in the test code to specify which method(s) a test method wants to
      test. If provided, only the code coverage information for the specified
      method(s) will be considered.
      <xref linkend="code-coverage-analysis.specifying-covered-methods.examples.BankAccountTest.php"/>
      shows an example.
    </para>

    <example id="code-coverage-analysis.specifying-covered-methods.examples.BankAccountTest.php">
      <title>Tests that specify which method they want to cover</title>
      <programlisting><![CDATA[<?php
require_once 'BankAccount.php';

class BankAccountTest extends PHPUnit_Framework_TestCase
{
    protected $ba;

    protected function setUp()
    {
        $this->ba = new BankAccount;
    }

    /**
     * @covers BankAccount::getBalance
     */
    public function testBalanceIsInitiallyZero()
    {
        $this->assertEquals(0, $this->ba->getBalance());
    }

    /**
     * @covers BankAccount::withdrawMoney
     */
    public function testBalanceCannotBecomeNegative()
    {
        try {
            $this->ba->withdrawMoney(1);
        }

        catch (BankAccountException $e) {
            $this->assertEquals(0, $this->ba->getBalance());

            return;
        }

        $this->fail();
    }

    /**
     * @covers BankAccount::depositMoney
     */
    public function testBalanceCannotBecomeNegative2()
    {
        try {
            $this->ba->depositMoney(-1);
        }

        catch (BankAccountException $e) {
            $this->assertEquals(0, $this->ba->getBalance());

            return;
        }

        $this->fail();
    }

    /**
     * @covers BankAccount::getBalance
     * @covers BankAccount::depositMoney
     * @covers BankAccount::withdrawMoney
     */

    public function testDepositWithdrawMoney()
    {
        $this->assertEquals(0, $this->ba->getBalance());
        $this->ba->depositMoney(1);
        $this->assertEquals(1, $this->ba->getBalance());
        $this->ba->withdrawMoney(1);
        $this->assertEquals(0, $this->ba->getBalance());
    }
}
?>]]></programlisting>
    </example>
  </section>

  <section id="code-coverage-analysis.ignoring-code-blocks">
    <title>Ignoring Code Blocks</title>

    <para>
      <indexterm><primary>Annotation</primary></indexterm>
      <indexterm><primary>@codeCoverageIgnore</primary></indexterm>
      <indexterm><primary>@codeCoverageIgnoreStart</primary></indexterm>
      <indexterm><primary>@codeCoverageIgnoreEnd</primary></indexterm>

      Sometimes you have blocks of code that you cannot test and that you may
      want to ignore during code coverage analysis. PHPUnit lets you do this
      using the <literal>@codeCoverageIgnore</literal>,
      <literal>@codeCoverageIgnoreStart</literal> and
      <literal>@codeCoverageIgnoreEnd</literal> annotations as shown in
      <xref linkend="code-coverage-analysis.ignoring-code-blocks.examples.Sample.php"/>.
    </para>

    <example id="code-coverage-analysis.ignoring-code-blocks.examples.Sample.php">
      <title>Using the <literal>@codeCoverageIgnore</literal>, <literal>@codeCoverageIgnoreStart</literal> and <literal>@codeCoverageIgnoreEnd</literal> annotations</title>
        <programlisting><![CDATA[<?php
/**
 * @codeCoverageIgnore
 */
class Foo
{
    public function bar()
    {
    }
}

class Bar
{
    /**
     * @codeCoverageIgnore
     */
    public function foo()
    {
    }
}

if (FALSE) {
    // @codeCoverageIgnoreStart
    print '*';
    // @codeCoverageIgnoreEnd
}
?>]]></programlisting>
    </example>

    <para>
      The lines of code that are markes as to be ignored using the annotations
      are counted as executed (if they are executable) and will not be
      highlighted.
    </para>
  </section>

  <section id="code-coverage-analysis.including-excluding-files">
    <title>Including and Excluding Files</title>

    <para>
      <indexterm><primary>Code Coverage</primary></indexterm>
      <indexterm><primary>Blacklist</primary></indexterm>
      <indexterm><primary>Whitelist</primary></indexterm>

      By default, all sourcecode files that contain at least one line of code
      that has been executed (and only these files) are included in the report.
      The sourcecode files that are included in the report can be filtered by
      using a blacklist or a whitelist approach.
    </para>

    <para>
      The blacklist is pre-filled with all sourcecode files of PHPUnit itself
      as well as the tests. When the whitelist is empty (default), blacklisting
      is used. When the whitelist is not empty, whitelisting is used. When
      whitelisting is used, each file on the whitelist is optionally added to
      the code coverage report regardless of whether or not it was executed.
    </para>

    <para>
      PHPUnit's XML configuration file (see <xref linkend="appendixes.configuration.blacklist-whitelist"/>)
      can be used to control the blacklist and the whitelist. Using a whitelist
      is the recommended best practice to control the list of files included in
      the code coverage report.
    </para>

    <para>
      <indexterm><primary>PHP_CodeCoverage_Filter</primary></indexterm>

      Alternatively, you can configure the sourcecode files that are included in
      the report using the <literal>PHP_CodeCoverage_Filter</literal> API.
    </para>
  </section>
</chapter>
